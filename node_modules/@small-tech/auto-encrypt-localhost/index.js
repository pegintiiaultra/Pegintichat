/**
  Automatically provisions and installs locally-trusted TLS certificates for Node.js https servers (including Express.js, etc.).

  @module @small-tech/auto-encrypt-localhost
  @copyright Â© 2019-present Aral Balkan, Small Technology Foundation.
  @license AGPLv3.
*/

import os from 'node:os'
import https from 'node:https'

import { DEFAULT_SETTINGS_PATH } from './lib/Constants.js'
import HttpServer from './lib/HttpServer.js'
import { getKeyMaterial } from './lib/TLS.js'
import events from './lib/Events.js'

// Ensure we only run on supported platforms (fail early).
const platform = os.platform()
if (platform !== 'linux' && platform !== 'darwin') {
  throw new Error(
    `Sorry, Auto Encrypt Localhost is not supported on ${platform}.
    (Supported platforms are Linux and macOS.)
  
    If you want to contribute support, please open an issue at:
    https://codeberg.org/small-tech/auto-encrypt-localhost

    Note: Windows support was removed on purpose and will not
    be added back as Microsoft is complicit in Israelâ€™s ongoing
    genocide of the Palestinian people (BDS).

    ðŸ‡µðŸ‡¸ To support families facing genocide in Gaza, consider
    donating to them directly: https://gaza-verified.org/donate

    Thank you.`
  )
}

/**
  Auto Encrypt Localhost is a static class. Please do not instantiate.

  Use: AutoEncryptLocalhost.https.createServer(â€¦)
*/
export default class AutoEncryptLocalhost {
  /**
    By aliasing the https property to the AutoEncryptLocalhost static class itself, we enable people to add AutoEncryptLocalhost to their existing apps by importing the module and prefixing their https.createServer(â€¦) line with AutoEncryptLocalhost.

    @example import AutoEncryptLocalhost from '@small-tech/auto-encrypt-localhost'
    const server = AutoEncryptLocalhost.https.createServer()

    @static
    @type {typeof AutoEncryptLocalhost}
  */
  static get https () { return AutoEncryptLocalhost }

  static events = events

  /**
    Returns the key material (certificate and private key) for the given settings path.

    @static
    @param {string} [settingsPath] The path to the settings directory.

    @returns {import('./lib/TLS.js').KeyMaterial} The key material.
  */
  static getKeyMaterial (settingsPath) {
    return getKeyMaterial(this.settingsPathWithDefaultFallback(settingsPath))
  }

  /**
    Returns the settings path or the default settings path if none is provided.

    @static
    @param {string} [settingsPath] The path to the settings directory.

    @returns {string} The settings path.
  */
  static settingsPathWithDefaultFallback (settingsPath) {
    return settingsPath || DEFAULT_SETTINGS_PATH
  }
  
  /**
    Automatically provisions trusted development-time (localhost) certificates in Node.js.

    @static
    @param {(import('node:http').ServerOptions & {settingsPath: string}) | import('node:http').RequestListener} [_options] Optional HTTPS options object with optional additional Auto Encrypt-specific configuration settings. If a function is passed, it is treated as the request listener.
    @param {import('node:http').RequestListener} [_listener] Optional request listener.

    @returns {Promise<import('./index.d.ts').AutoEncryptedLocalhostServer>}
  */
  static async createServer(_options, _listener) {
    // The first parameter is optional. If omitted, the first argument, if any, is treated as the request listener.
    if (typeof _options === 'function') {
      _listener = _options
      _options = null
    }

    const options = /** @type { (import('node:http').ServerOptions & {settingsPath: string}) } */ (_options) || { settingsPath: null }
    const listener = _listener || null

    const settingsPath = this.settingsPathWithDefaultFallback(options.settingsPath)

    // Get the key material (cert and key) and add them to the options
    // object. If a certificate authority and certificate needs to be
    // created or renewed, that will all be handled for us.
    const keyMaterial = getKeyMaterial(settingsPath)
    Object.assign(options, {cert: keyMaterial.cert, key: keyMaterial.key})

    // Start HTTP server.
    await HttpServer.getSharedInstance(keyMaterial.certificateAuthority)

    // Create HTTPS server.
    const server = /** @type {import('./index.d.ts').AutoEncryptedLocalhostServer} */ (/** @type {unknown} */ (https.createServer(options, listener)))

    //
    // Monkey-patch server.
    //

    /**
      Auto Encrypt Localhostâ€™s async version of Nodeâ€™s built-in `https.listen()` method.

      You can use this method with exactly the same signature as Nodeâ€™s and
      with a callback but, ideally, you should be awaiting it and not using the callback.
    
      @param {...*} args - Arguments to pass to https.Server.listen()
      @returns {Promise<import('./index.d.ts').AutoEncryptedLocalhostServer>}
    */
    const listenAsync = async function (...args) {
      return new Promise((resolve, reject) => {
        const server = this['__original_listen__'](...args)
          .once('listening', () => resolve(server))
          .once('error', reject)
      })
    }
    server['__original_listen__'] = server.listen.bind(server)
    server.listen = listenAsync.bind(server)

    /**
      Auto Encrypt Localhostâ€™s async version of Nodeâ€™s built-in `https.close()` method.

      Unlike Nodeâ€™s `close()` method, this version also calls `closeAllConnections()` so it
      will sever any existing idle and active connections. When `await`ed, this call will
      only return once `node:https`â€™s close callback is called. This is also where your
      callback will fire, if you are using Nodeâ€™s original method signature will callbacks.

      You can still use this method with exactly the same signature as Nodeâ€™s and
      with a callback but, ideally, you should be awaiting it and not using the callback.
    
      @returns {Promise<void>}
    */
    const closeAsync = async function () {
      // Shut down HTTP redirection server.
      await HttpServer.destroySharedInstance()

      // Start shutting down the HTTPS server.
      const closePromise = new Promise((resolve, reject) => {
        this['__original_close__']((/** @type {Error} */ error) => {
          if (error) {
            reject(error)
          } else {
            resolve()
          }
        })
      })

      // Sever all idle and active connections.
      this.closeAllConnections()

      // Only now await the promise.
      // (See note at: https://nodejs.org/docs/latest-v24.x/api/http.html#servercloseallconnections)
      await closePromise
    }
    server['__original_close__'] = server.close.bind(server)
    server.close = closeAsync.bind(server)

    return server
  }
}
