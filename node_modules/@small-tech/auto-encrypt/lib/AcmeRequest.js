/**
  Abstract base request class for carrying out signed ACME requests over HTTPS.

  @module
  @copyright Copyright ¬© 2020 Aral Balkan, Small Technology Foundation.
  @license AGPLv3 or later.
*/

import packageJson from '../package.json' with { type: 'json' }
import crypto from 'node:crypto'
import Nonce from './Nonce.js'
import Throws from './util/Throws.js'
import log from './util/log.js'

const throws = new Throws({
  [Symbol.for('AcmeRequest.classNotInitialisedError')]:
    () => 'You cannot create instances of the AcmeRequest class before initialising it via AcmeRequest.initialise()',

  [Symbol.for('AcmeRequest.accountNotSetError')]:
    () => 'You cannot issue calls that require an account KeyId without first injecting a reference to the account',

  [Symbol.for('AcmeRequest.requestError')]:
    (/** @type {{ status: number, type: string, detail: string }} */ error) => `(${error.status} ${error.type} ${error.detail})`
})

/**
  Abstract base request class for carrying out signed ACME requests over HTTPS.

  @alias module:lib/AcmeRequest
*/
export default class AcmeRequest {
  static initialised = false
  static initialisationPromise = null

  /** @import('./Directory.js').default */
  static directory = null

  /** @import('./identities/AccountIdentity.js').default */
  static accountIdentity = null

  static nonce = null
  static __account = null
  /** @type {string} */
  static autoEncryptVersion = packageJson.version

  /**
    Initialise the AcmeRequest class with the directory and account identity.

    @param {import('./Directory.js').default|void} directory - (Required) The ACME directory.

    @param {import('./identities/AccountIdentity.js').default|void} accountIdentity - (Required) The account identity.
  */
  static initialise (directory = throws.ifMissing(), accountIdentity = throws.ifMissing()) {
    AcmeRequest.directory = /** @type { import('./Directory.js').default } */ (directory)
    AcmeRequest.accountIdentity = accountIdentity
    AcmeRequest.nonce = new Nonce(AcmeRequest.directory)
    AcmeRequest.initialised = true
  }

  static uninitialise () {
    AcmeRequest.directory = null
    AcmeRequest.accountIdentity = null
    AcmeRequest.nonce = null
    AcmeRequest.__account = null
    AcmeRequest.initialised = false
    AcmeRequest.initialisationPromise = null
  }

  static set account (/** import('./Account.js').default */ _account) { AcmeRequest.__account = _account }

  /** @returns { import('./Account.js').default } */
  static get account () { return AcmeRequest.__account }

  constructor () {
    if (!AcmeRequest.initialised) {
      throws.error(Symbol.for('AcmeRequest.classNotInitialisedError'))
    }
  }

  /**
    Executes a remote Let‚Äôs Encrypt command and either returns the result or throws.

    @param {string|void} command - (Required) Name of {@link Directory} command to invoke e.g. 'newAccount'.

    @param {Object|string|void} payload - (Required) Object to use as payload. For no payload, pass empty string.

    @param {boolean} [useKid=true] - Use Key ID (true) or public JWK (false) (see RFC 8555 ¬ß 6.2).

    @param {Number[]} [successCodes=[200]] - Optional array of codes that signals success. Any other code throws.

    @param {string} [url=null] - If specified, use this URL, ignoring the command parameter.

    @param {boolean} [parseResponseBodyAsJSON=true] - Parse response body as JSON (true) or as string (false).
  */
  async request (
    command                 = throws.ifMissing(),
    payload                 = throws.ifMissing(),
    useKid                  = true,
    successCodes            = [200],
    url                     = null,
    parseResponseBodyAsJSON = true
  ) {
    if (useKid && AcmeRequest.account === null) { throws.error(Symbol.for('AcmeRequest.accountNotSetError')) }

    const preparedRequest = await this.prepare(/** @type { string } */ (command), payload, useKid, successCodes, url)
    const responseObject = await this._execute(preparedRequest, parseResponseBodyAsJSON)
    return responseObject
  }

  /**
    Executes a prepared request.

    @param {Awaited<ReturnType<typeof this.prepare>>|void} preparedRequest - (Required) The prepared request, ready to be executed.

    @param {boolean|void} parseResponseBodyAsJSON - (Required) Should the request body be parsed as JSON (true) or should the native response object be returned (false).
  */
  async _execute (preparedRequest = throws.ifMissing(), parseResponseBodyAsJSON = throws.ifMissing()) {
    const { signedRequest, httpsRequest, httpsHeaders, originalRequestDetails } = /** @type {Awaited<ReturnType<typeof this.prepare>>} */ (preparedRequest)

    let response, errorHeaders, errorBody
    try {
      response = await httpsRequest('', signedRequest, httpsHeaders)
    } catch (error) {
      errorBody = error.responseBody
      errorHeaders = error.headers

      // The error body is a promise. Wait for it to resolve.
      if (errorBody) {
        const errorBodyBuffer = await errorBody
        const errorBodyString = Buffer.from(errorBodyBuffer).toString('utf-8')

        // If the error body is JSON (i.e., as expected to be returned from Let‚Äôs Encrypt),
        // handle it. If not (for whatever reason), still handle the error gracefully.
        let acmeError = null
        try {
          acmeError = JSON.parse(errorBodyString)
        } catch (_) {
          acmeError = {
            status: -1,
            type: 'Unexpected error',
            detail: errorBodyString
          }
        }

        // If it‚Äôs valid JSON but doesn‚Äôt have the expected ACME error fields, wrap it.
        if (acmeError && acmeError.status === undefined && acmeError.type === undefined) {
          acmeError = {
            status: -1,
            type: 'Unexpected JSON error',
            detail: errorBodyString
          }
        }

        // According to RFC 8555 ¬ß 6.5, a bad nonce error should result in retry attempt.
        if (acmeError.status === 400 && acmeError.type === 'urn:ietf:params:acme:error:badNonce') {
          log('   üîÑ    ‚ù®auto-encrypt‚ù© Server returned a bad nonce error. Retrying with provided nonce. (RFC 8555 ¬ß 6.5)')
          const serverProvidedNonce = errorHeaders && errorHeaders['replay-nonce']

          if (!serverProvidedNonce) {
            throws.error(Symbol.for('AcmeRequest.requestError'), acmeError)
          }

          // Take the original request details (arguments array passed to the prepare() method) and
          // re-prepare and retry the request, replacing the nonce (last argument), with the one provided
          // by the ACME server.
          const originalRequestWithServerProvidedNonce = [...originalRequestDetails]
          originalRequestWithServerProvidedNonce[originalRequestWithServerProvidedNonce.length - 1] = serverProvidedNonce

          return await this._execute(
            await this.prepare(...originalRequestWithServerProvidedNonce),
            parseResponseBodyAsJSON
          )
        }

        throws.error(Symbol.for('AcmeRequest.requestError'), acmeError)
      }

      // If we got here, it's a non-ACME error (e.g. network error).
      throw error
    }

    // Always save the fresh nonce returned from API calls.
    const freshNonce = response.headers.get('replay-nonce')
    AcmeRequest.nonce.set(freshNonce)

    // The response returned is the raw response object. Let‚Äôs consume
    // it and return a more relevant response.
    const headers = Object.fromEntries(response.headers.entries())
    const responseBodyBuffer = await this.getBuffer(response)
    let body = responseBodyBuffer.toString('utf-8')
    if (parseResponseBodyAsJSON) {
      body = JSON.parse(body)
    }

    return {
      headers,
      body
    }
  }

  /**
    Returns a buffer from the response body.

    @param {Response} response - (Required) A fetch response.

    @returns {Promise<Buffer>} The body of the response as a buffer.
  */
  async getBuffer (response) {
    return Buffer.from(await response.arrayBuffer())
  }

  /**
    Separate the preparation of a request from the execution of it so we can easily test that different request configurations conform to our expectations.

    @param {string|void} command - (Required) Name of Let‚Äôs Encrypt command to invoke (see Directory; sans 'Url' suffix). e.g. 'newAccount', 'newOrder', etc.

    @param {Object|string|void} payload - (Required) Either an object to use as the payload or, if there is no payload, an empty string.

    @param {boolean|void} useKid - (Required) Should request use a Key ID (true) or, public JWK (false). (See RFC 8555 ¬ß 6.2 Request Authentication.)

    @param {Number[]} [successCodes=[200]] - Optional array of codes that signals success. Any other code throws.

    @param {string} [url=null] - If specified, will use this URL directly, ignoring the value in the command parameter.

    @param {Nonce} [nonce=null] - If specified, the nonce to use.
  */
  async prepare (
    command = throws.ifMissing(),
    payload = throws.ifMissing(),
    useKid = throws.ifMissing(),
    successCodes = [200],
    url = null,
    nonce = null
  ) {
    command = /** @type { String } */ (command)
    payload = /** @type { Object | String } */ (payload)
    useKid = /** @type { Boolean } */ (useKid)

    if (useKid && AcmeRequest.account === null) { throws.error(Symbol.for('AcmeRequest.accountNotSetError')) }

    // We will also return the original request details in case the call needs to be retried later. Note: we have to create our own object using the actual individual argument values instead of the arguments array as the latter does not reflect default parameters.
    const originalRequestDetails = [command, payload, useKid, successCodes, url, nonce]

    url = url || AcmeRequest.directory[`${command}Url`]

    // Capture static state at the beginning of method to avoid race conditions if uninitialise() is called while awaiting a nonce. (This should really only be a race condition encountered during unit tests, but still.)
    const account = AcmeRequest.account
    const accountIdentity = AcmeRequest.accountIdentity

    const protectedHeader = {
      alg: 'RS256',
      nonce: nonce || await AcmeRequest.nonce.get(),
      url
    }

    if (useKid) {
      // The kid is the account location URL as previously returned by the ACME server.
      protectedHeader.kid = account.kid
    } else {
      // If we‚Äôre not using the kid, we must use the public JWK (see RFC 8555 ¬ß 6.2 Request Authentication)
      protectedHeader.jwk = accountIdentity.publicJWK
    }

    // Flatten the payload and sign it and use the signature in the signed request.
    // (We were previously using jose.FlattenedSign for this.)

    const encoder = new TextEncoder()
    const protectedHeaderBase64 = Buffer.from(encoder.encode(JSON.stringify(protectedHeader))).toString('base64url')
    const payloadBase64 = Buffer.from(typeof payload === 'string' ? encoder.encode(payload) : encoder.encode(JSON.stringify(payload))).toString('base64url')

    const signature = crypto.sign(
      'sha256',
      Buffer.from(`${protectedHeaderBase64}.${payloadBase64}`),
      accountIdentity.key
    )

    const signedRequest = {
      protected: protectedHeaderBase64,
      payload: payloadBase64,
      signature: signature.toString('base64url')
    }

    const httpsHeaders = {
      'Content-Type': 'application/jose+json',
      'User-Agent': `small-tech.org-auto-encrypt/${AcmeRequest.autoEncryptVersion}`,
      'Accept-Language': 'en-US'
    }

    // Carries out an https request.
    const httpsRequest = async (/** @type {string} */ _path, /** @type {any} */ body, /** @type {any} */ headers) => {
      const response = await fetch(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(body)
      })

      if (!successCodes.includes(response.status)) {
        const error = new Error(`HTTP Error: ${response.status} ${response.statusText}`)
        // @ts-ignore Error object mixin.
        error.status = response.status
        // @ts-ignore Error object mixin.
        error.headers = Object.fromEntries(response.headers.entries())
        // @ts-ignore Error object mixin.
        error.responseBody = response.arrayBuffer().then(Buffer.from)
        throw error
      }

      return response
    }

    return {
        protectedHeader,
        signedRequest,
        httpsRequest,
        httpsHeaders,
        originalRequestDetails
    }
  }
}
