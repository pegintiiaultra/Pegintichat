/**
  Order

  (Please use async factory method Order.getInstanceAsync() to instantiate.)

  Represents a Let‚Äôs Encrypt order.
  See RFC 8555 ¬ß 7.1.3 (Order Objects), 7.4 (Applying for Certificate Issuance)

  Copyright ¬© 2020-present Aral Balkan, Small Technology Foundation.
  License: AGPLv3 or later.
*/

import fsPromises from 'fs/promises'
import Authorisation from './Authorisation.js'
import HttpServer from './HttpServer.js'
import CertificateIdentity from './identities/CertificateIdentity.js'
import acmeCsr from './acmeCsr.js'
import asyncForEach from './util/async-foreach.js'
import log from './util/log.js'
import NewOrderRequest from './acme-requests/NewOrderRequest.js'
import FinaliseOrderRequest from './acme-requests/FinaliseOrderRequest.js'
import CheckOrderStatusRequest from './acme-requests/CheckOrderStatusRequest.js'
import CertificateRequest from './acme-requests/CertificateRequest.js'
import Throws from './util/Throws.js'
import waitFor from './util/waitFor.js'

const throws = new Throws()

export default class Order {
  #data                = null
  #headers             = null
  #location            = null
  #order               = null
  #certificate         = null
  #certificateIdentity = null

  /** @type { Array<Authorisation> } */
  #authorisations      = []

  /** @type { import('./Configuration.js').default } */
  configuration

  /** @type { import('./identities/AccountIdentity.js').default } */
  accountIdentity

  /** @type { string } */
  ariCertId

  //
  // Factory method (async).
  //
  static isBeingInstantiatedViaFactoryMethod = false

  /**
    Async factory method. Use this to instantiate this class.
    
    @param { import('./Configuration.js').default | void } configuration (Required) Configuration instance.
    @param { import('./identities/AccountIdentity.js').default | void } accountIdentity (Required) Account identity.
    @param { string | void } ariCertId (Required) ARI certificate ID.
  */
  static async createAsync (configuration = throws.ifMissing(), accountIdentity = throws.ifMissing(), ariCertId = throws.ifMissing()) {
    Order.isBeingInstantiatedViaFactoryMethod = true
    const instance = new Order(configuration, accountIdentity, ariCertId)
    await instance.init()
    return instance
  }

  get certificate         () { return this.#certificate                             }
  get certificateIdentity () { return this.#certificateIdentity                     }
  get authorisations      () { return this.#authorisations                          }
  get finaliseUrl         () { return this.#order ? this.#order.finalize : null     }
  get identifiers         () { return this.#order ? this.#order.identifiers : null  }
  get status              () { return this.#order ? this.#order.status : null       }
  get expires             () { return this.#order ? this.#order.expires : null      }
  get certificateUrl      () { return this.#order ? this.#order.certificate : null  }
  get headers             () { return this.#headers                                 }

  //
  // Private.
  //

  get data () { return this.#data }
  set data (value) {
    this.#data = value
    // It seems that Let‚Äôs Encrypt are no longer sending the location
    // back on status checks, only on order finalisation, so let‚Äôs\
    // make sure we don‚Äôt accidentally.
    if (this.#data.headers.location !== undefined) this.#location = this.#data.headers.location
    this.#headers = this.#data.headers
    this.#order = this.#data.body
  }

  set certificate         (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'certificate')         }
  set certificateIdentity (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'certificateIdentity') }
  set authorisations      (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'authorisations')      }
  set finaliseUrl         (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'finaliseUrl')         }
  set identifiers         (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'identifiers')         }
  set status              (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'status')              }
  set expires             (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'expires')             }
  set certificateUrl      (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'certificateUrl')      }
  set headers             (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'headers')             }

  //
  // Private.
  //

  /**
    Creates an instance of Order.

    @param { import('./Configuration.js').default | void } configuration (Required) Configuration instance.
    @param { import('./identities/AccountIdentity.js').default | void } accountIdentity (Required) Account identity.
    @param { string | void } ariCertId (Required) ARI certificate ID.
  */
  constructor (configuration = throws.ifMissing(), accountIdentity = throws.ifMissing(), ariCertId = throws.ifMissing()) {
    // Ensure singleton access.
    if (Order.isBeingInstantiatedViaFactoryMethod === false) {
      throw new Error('Order constructor is private. Please instantiate using :await Order.getInstanceAsync().')
    }

    this.configuration   = /** @type { import('./Configuration.js').default } */ (configuration)
    this.domains         = this.configuration.domains
    this.accountIdentity = /** @type { import('./identities/AccountIdentity.js').default } */ (accountIdentity)
    this.ariCertId       = /** @type { string } */ (ariCertId)

    Order.isBeingInstantiatedViaFactoryMethod = false
  }


  async init () {
    try {
      this.data = await ((new NewOrderRequest()).execute(this.configuration, this.ariCertId))
    } catch (error) {
      if (this.ariCertId !== null) {
        log(`   ‚ö†    ‚ù®auto-encrypt‚ù© Failed to create order with ARI replacement info (${error.message}). Retrying without it‚Ä¶`)
        try {
          this.data = await ((new NewOrderRequest()).execute(this.configuration, null))
        } catch (retryError) {
          throw new Error(retryError)
        }
      } else {
        throw new Error(error)
      }
    }

    this.#authorisations = []

    let numberOfAuthorisationsValidated = 0
    let numberOfAuthorisationsToValidate = this.domains.length

    log(`   üìà    ‚ù®auto-encrypt‚ù© Number of authorisations to validate: ${numberOfAuthorisationsToValidate}`)

    // We‚Äôve got the order back. Download all the authorisations and
    // create Authorisation instances from them. The Authorisation
    // instances will handle settings up to answer their challenges themselves.
    await asyncForEach(
      this.data.body.authorizations,
      async ( /** @type { string } */ authorisationUrl ) => {
        // An authorisation only returns when it is validated.
        // TODO: handle errors.
        const authorisation = await Authorisation.getInstanceAsync(authorisationUrl, this.accountIdentity)

        numberOfAuthorisationsValidated++

        log(`   üìù    ‚ù®auto-encrypt‚ù© An authorisation was validated for the order! (${numberOfAuthorisationsValidated}/${numberOfAuthorisationsToValidate})`)

        this.#authorisations.push(authorisation)
      }
    )

    // At this point, all authorisations have been validated. Now, finalise the order and send the CSR.
    // ‚ÄúOnce the client believes it has fulfilled the server's requirements,
    // it should send a POST request to the order resource's finalize URL.
    // The POST body MUST include a CSR.‚Äù ‚Äì RFC 8555 ¬ß 7.4 (Applying for Certificate Issuance).

    log(`   üéä    ‚ù®auto-encrypt‚ù© All authorisations validated.`)

    // We no longer need the HTTP server in Challenge Server mode (as place in by the authorisations).
    // When we turn Challenge Server off, it will start redirecting any HTTP calls its receives to HTTPS.
    const httpServer = await HttpServer.getSharedInstance()
    httpServer.challengeServer = false

    log(`   üíÉ    ‚ù®auto-encrypt‚ù© Finalising order‚Ä¶`)

    // Generate and save certificate‚Äôs identity (private key).
    this.#certificateIdentity = new CertificateIdentity(this.configuration)

    // Generate a Certificate Signing Request in the unique format that ACME expects.
    const csr = acmeCsr(this.domains, this.certificateIdentity.key)

    let numAttempts = 0
    while (this.status !== 'valid' && this.status !== 'invalid') {
      numAttempts++

      if (numAttempts > 5) {
        log(`   ‚ùå    ‚ù®auto-encrypt‚ù© Timed out waiting for order validity. `)
        break;
      }

      try {
        if (numAttempts === 1) {
          // Finalise using CSR.
          log('   üìù    ‚ù®auto-encrypt‚ù© Finalising using CSR.')
          this.data = await (new FinaliseOrderRequest()).execute(this.finaliseUrl, csr)
        } else {
          // Check for order status.
          log('   üëÄ    ‚ù®auto-encrypt‚ù© Checking for order status.')
          this.data = await (new CheckOrderStatusRequest()).execute(this.#location)
        }
      } catch (error) {
        // TODO: Handle error.
        throw new Error(error)
      }

      if (this.status === 'valid') {
        log('   üéÅ    ‚ù®auto-encrypt‚ù© Order is valid.')

        // Download and cache the certificate.
        try {
          const certificateResponse = await ((new CertificateRequest)).execute(this.certificateUrl)
          this.#certificate = certificateResponse.body
        } catch (error) {
          throw new Error(error)
        }

        log('   üíÖ    ‚ù®auto-encrypt‚ù© Got the certificate.')

        // Save the certificate.
        try {
          await fsPromises.writeFile(this.configuration.certificatePath, this.certificate, 'utf-8')
        } catch (error) {
          throw new Error(error)
        }

        log('   üíæ    ‚ù®auto-encrypt‚ù© Saved the certificate.')
      } else {
        log(` ‚ÑπÔ∏è Order is not valid. Current status: (${this.status})`)

        if (this.status === 'invalid')
        {
          // To let renewal attempts naturally retry every day, we let this pass.
          log(`   ‚ùå    ‚ù®auto-encrypt‚ù© Order is invalid. `)
        } else {
          log(`   ‚è≥    ‚ù®auto-encrypt‚ù© Waiting a second before checking again‚Ä¶`)
          await waitFor(1000)
        }
      }
    }
  }
}
