/**
  Represents a Let‚Äôs Encrypt TLS certificate.

  @module
  @copyright Copyright ¬© 2020-present Aral Balkan, Small Technology Foundation.
  @license AGPLv3 or later.
*/

import fs from 'fs'
import tls from 'tls'
import util from 'util'
import { Temporal } from 'temporal-polyfill'
import log from './util/log.js'
import fromNow from './util/fromNow.js'
import { Certificate as X509Certificate, CertificateSerialNumber } from './x.509/rfc5280.js'
import Account from './Account.js'
import AccountIdentity from './identities/AccountIdentity.js'
import Directory from './Directory.js'
import Order from './Order.js'
import CertificateIdentity from './identities/CertificateIdentity.js'
import AcmeRequest from './AcmeRequest.js'
import Throws from './util/Throws.js'

const throws = new Throws({
  // No custom errors are thrown by this class.
})

/**
  Represents a Let‚Äôs Encrypt TLS certificate.

  @alias module:lib/Certificate
  @param {String[]} domains List of domains this certificate covers.
*/
export default class Certificate {
  /**
    Get a SecureContext that can be used in an SNICallback.

    @category async
    @returns {Promise<tls.SecureContext>} A promise for a SecureContext that can be used in creating https servers.
  */
  async getSecureContext () {
    if (!this.#secureContext) {
      if (this.#busyCreatingSecureContextForTheFirstTime) {
        return null
      }

      // We don‚Äôt have the secure context yet, create it.
      await this.createSecureContext()
    }
    return this.#secureContext
  }

  /**
    Creates an instance of Certificate.

    @param {import('./Configuration.js').default|void} configuration Configuration instance.
  */
  constructor (configuration = throws.ifMissing()) {
    this.#configuration = /** @type {import('./Configuration.js').default} */ (configuration)
    this.attemptToRecoverFromFailedRenewalAttemptIfNecessary()
    this.#domains = this.#configuration.domains

    // If the certificate already exists, load and cache it.
    if (fs.existsSync(this.#configuration.certificatePath)) {
      this.pem = fs.readFileSync(this.#configuration.certificatePath, 'utf-8')
      this.identity = new CertificateIdentity(this.#configuration)

      log('   üìÉ    ‚ù®auto-encrypt‚ù© Certificate exists, loaded it (and the corresponding private key) from disk.')
      this.startCheckingForRenewal(/* alsoCheckNow = */ true)
    } else {
      log('   üìÉ    ‚ù®auto-encrypt‚ù© Certificate does not exist; will be provisioned at server start.')
    }
  }

  //
  // Private.
  //

  /** @type {import('./Configuration.js').default} */
  #configuration = null
  #account = null
  #accountIdentity = null
  #directory = null
  #secureContext = null
  #domains = null
  #checkForRenewalIntervalId = null
  #busyCreatingSecureContextForTheFirstTime = false

  /** @type {string | Buffer | Array<string | Buffer> | undefined} */
  #_pem = null

  #_identity = null

  /**  @type {string | Buffer | Array<string | Buffer | {
        pem: string | Buffer;
        passphrase?: string | undefined;
    }> | undefined} */
  #_key = null

  #_issuer = null
  #_subject = null
  #_alternativeNames = null
  #_serialNumber = null
  #_issueDate = null
  #_expiryDate = null
  #_ariCertId = null

  get isProvisioned     () { return this.#_pem !== null      }
  get pem               () { return this.#_pem               }
  get identity          () { return this.#_identity          }
  get key               () { return this.#_key               }
  get serialNumber      () { return this.#_serialNumber      }
  get issuer            () { return this.#_issuer            }
  get subject           () { return this.#_subject           }
  get alternativeNames  () { return this.#_alternativeNames  }
  get issueDate         () { return this.#_issueDate         }
  get expiryDate        () { return this.#_expiryDate        }
  get ariCertId         () { return this.#_ariCertId         }

  set pem (certificatePem) {
    this.#_pem = certificatePem

    const details = this.parseDetails(certificatePem)
    this.#_serialNumber      = details.serialNumber
    this.#_issuer            = details.issuer
    this.#_subject           = details.subject
    this.#_alternativeNames  = details.alternativeNames
    this.#_issueDate         = Temporal.Instant.from(details.issuedAt.toISOString())
    this.#_expiryDate        = Temporal.Instant.from(details.expiresAt.toISOString())
    this.#_ariCertId         = details.ariCertId

    // Display the certificate with a nice border :)
    const logMessagePrefix = '         ‚ù®auto-encrypt‚ù© '

    let logMessageBody = [
      `Serial number    : ${details.serialNumber}`,
      `Issuer           : ${details.issuer}`,
      `Subject          : ${details.subject}`,
      `Alternative names: ${details.alternativeNames.reduce((/** @type { string } */ string, /** @type { string } */ name) => `${string}, ${name}`)}`,
      `Issued on        : ${this.issueDate.toLocaleString()} (${fromNow(this.issueDate)})`,
      `Expires on       : ${this.expiryDate.toLocaleString()} (${fromNow(this.expiryDate)})`
    ]

    const longestLineLength = logMessageBody.reduce((accumulator, currentValue) => currentValue.length > accumulator ? currentValue.length : accumulator, 0)

    const horizontalBar = '‚îÄ'.repeat(longestLineLength+2) // +2 is for the one-space padding at each side of a line.
    const topBorder = `${logMessagePrefix}‚ï≠${horizontalBar}‚ïÆ`
    const bottomBorder = `${logMessagePrefix}‚ï∞${horizontalBar}‚ïØ`

    logMessageBody = logMessageBody.map(line => {
      return `${logMessagePrefix}‚îÇ ${line}${' '.repeat(longestLineLength - line.length)} ‚îÇ`
    })

    log(`   üéÄ    ‚ù®auto-encrypt‚ù© Certificate ready:\n${topBorder}\n${logMessageBody.join('\n')}\n${bottomBorder}`)
  }

  set identity (certificateIdentity) {
    this.#_identity = certificateIdentity
    this.#_key = certificateIdentity.privatePEM
  }

  set key              (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'key', 'set via identity')         }
  set serialNumber     (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'serialNumber', 'set via pem')     }
  set issuer           (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'issuer', 'set via pem')           }
  set subject          (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'subject', 'set via pem')          }
  set alternativeNames (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'alternativeNames', 'set via pem') }
  set issueDate        (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'issueDate', 'set via pem')        }
  set expiryDate       (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'expiryDate', 'set via pem')       }

  /**
    Check if certificate-identity.pem.old or certificate.pem.old files exist.
    If they do, it means that something went wrong while  certificate was trying to be
    renewed. So restore them and use them and hopefully the next renewal attempt will
    succeed or at least buy the administrator of the server some time to fix the issue.
  */
  attemptToRecoverFromFailedRenewalAttemptIfNecessary () {
    const oldCertificateIdentityPath = `${this.#configuration.certificateIdentityPath}.old`
    const oldCertificatePath = `${this.#configuration.certificatePath}.old`
    const certificateIdentityPath = this.#configuration.certificateIdentityPath
    const certificatePath = this.#configuration.certificatePath

    if (fs.existsSync(oldCertificateIdentityPath) && fs.existsSync(oldCertificatePath)) {
      log('   üöë    ‚ù®auto-encrypt‚ù© Warning: Failed renewal attempt detected. Old certificate files found. Attempting to recover‚Ä¶')
      // Edge case: check if the process succeeded (perhaps the power went out right after the certificate was
      // written but before we had a chance to clean up the old files.)
      if (fs.existsSync(certificateIdentityPath) && fs.existsSync(certificatePath)) {
        log('   üöë    ‚ù®auto-encrypt‚ù© A new certificate was also found. Going to delete the old one and use that.')
        fs.rmSync(oldCertificateIdentityPath)
        fs.rmSync(oldCertificatePath)
      } else {
        // The renewal process must have failed. Delete any previous state and restore the old certificate.
        log('   üöë    ‚ù®auto-encrypt‚ù© Cleaning up previous state and restoring old certificate‚Ä¶')
        fs.renameSync(oldCertificateIdentityPath, certificateIdentityPath)
        fs.renameSync(oldCertificatePath, certificatePath)
      }
      log('   üöë    ‚ù®auto-encrypt‚ù© Recovery attempt complete.')
    }
  }

  /**
    Initialises the ACME request, providing an asynchronous lock to prevent race conditions.
    
    In Auto Encrypt, the initialisation of ACME state (AcmeRequest, Directory, Account) can be triggered by two independent events:

      1. Renewal check on existing certificate at startup. When the server is created and a certificate already exists on disk, the `Certificate` constructor triggers `checkForRenewal()`. This runs in the background, calls `#initialiseAcmeRequest()`, and is not awaited by the constructor.

      2. An incoming request: When the HTTPS server receives its first request, the SNICallback calls `getSecureContext()` and this, in turn, calls `createSecureContext()` and `#initialiseAcmeRequest()`.

    This is why we use a shared static promise on the AcmeRequest class as a lock to ensure that initialisation only happens once.

    TODO: This is no longer the case with the move to the asynchronous API for AutoEncrypt.https.createServer(). So it should be OK to remove the lock.
  */
  async #initialiseAcmeRequest () {
    if (AcmeRequest.initialised && this.#directory && this.#accountIdentity && this.#account) {
      return
    }

    if (AcmeRequest.initialisationPromise) {
      await AcmeRequest.initialisationPromise
    }

    if (!AcmeRequest.initialised) {
      AcmeRequest.initialisationPromise = (async () => {
        try {
          log('   ‚öôÔ∏è    ‚ù®auto-encrypt‚ù© Initialising ACME request state‚Ä¶')
          const directory = await Directory.getInstanceAsync(this.#configuration)
          const accountIdentity = new AccountIdentity(this.#configuration)
          AcmeRequest.initialise(directory, accountIdentity)
          const account = await Account.getInstanceAsync(this.#configuration)
          AcmeRequest.account = account
        } catch (error) {
          // Reset state on failure so we can try again.
          AcmeRequest.uninitialise()
          throw error
        } finally {
          AcmeRequest.initialisationPromise = null
        }
      })()
      await AcmeRequest.initialisationPromise
    }

    // Populate instance references from the static AcmeRequest state.
    this.#directory = AcmeRequest.directory
    this.#accountIdentity = AcmeRequest.accountIdentity
    this.#account = AcmeRequest.account
  }

  /**
    Creates and caches a secure context, provisioning a TLS certificate in the process, if necessary.

    @category async
    @access private
    @param {Boolean} renewCertificate If true, will start the process of renewing the certificate
                                      (but will continue to return the existing certificate until it is ready).
    @returns {Promise}                Fulfils immediately if certificate exists and does not need to be
                                      renewed. Otherwise, fulfils when certificate has been provisioned.
  */
  async createSecureContext (renewCertificate = false) {
    // If we‚Äôre provisioning a certificate for the first time,
    // block all other calls. If we‚Äôre renewing, we don‚Äôt
    // want to do that as we already have a valid certificate
    // to serve.
    if (!renewCertificate) {
      this.#busyCreatingSecureContextForTheFirstTime = true
    }

    // If the certificate does not already exist, provision one.
    if (!this.pem || renewCertificate) {
      // Initialise all necessary state.
      await this.#initialiseAcmeRequest()

      await this.provisionCertificate(renewCertificate ? this.#_ariCertId : null)
    }

    // Create and cache the secure context.
    this.#secureContext = tls.createSecureContext({
      key: this.key,
      cert: this.pem
    })

    // No need to do an additional check for renewal here
    // as setting this to false when it is already false
    // will not have an undesirable effect.
    this.#busyCreatingSecureContextForTheFirstTime = false
  }


  /**
    Provisions a new Let‚Äôs Encrypt TLS certificate, persists it, and starts checking for
    renewals on it every hour, starting with the next hour.

    @access private
    @param {string|void} ariCertId
    @category async
    @returns {Promise} Fulfils once a certificate has been provisioned.
  */
  async provisionCertificate (ariCertId = throws.ifMissing()) {
    log(`   ü§ñ    ‚ù®auto-encrypt‚ù© Provisioning Let‚Äôs Encrypt certificates for ${this.#domains}.`)

    // Create a new order.
    const order = await Order.createAsync(this.#configuration, this.#accountIdentity, ariCertId)

    // Get the certificate details from the order.
    this.pem = order.certificate
    this.identity = order.certificateIdentity

    // Start checking for renewal updates, every hour, starting in an hour.
    this.startCheckingForRenewal(/* alsoCheckNow = */ false)

    log(`   üéâ    ‚ù®auto-encrypt‚ù© Successfully provisioned Let‚Äôs Encrypt certificate for ${this.#domains}.`)
  }

  /**
    Starts the certificate renewal process by requesting the creation of a fresh secure context.

    @access private
    @returns {Promise} Resolves once certificate is renewed and new secure context is
                                  created and cached.
    @category async
  */
  async renewCertificate () {
    //
    // Backup the existing certificate and certificate identity (*.pem ‚Üí *.pem.old). Then create a new
    // Order and, if it‚Äôs successful, update the certificate and certificate identity and recreate and
    // cache the secureContext so that the server will start using the new certificate right away.
    // If it‚Äôs not successful, restore the old files.
    //
    log(`   ü§ñ    ‚ù®auto-encrypt‚ù© Renewing Let‚Äôs Encrypt certificate for ${this.#domains}.`)

    this.stopCheckingForRenewal()

    //
    // In case old files were left behind, remove them first and then rename the current files.
    // (If the directory doesn‚Äôt exist, will silently do nothing.)
    //
    const certificateIdentityPath = this.#configuration.certificateIdentityPath
    const oldCertificateIdentityPath = `${certificateIdentityPath}.old`
    const certificatePath = this.#configuration.certificatePath
    const oldCertificatePath = `${certificatePath}.old`

    fs.renameSync(certificateIdentityPath, oldCertificateIdentityPath)
    fs.renameSync(certificatePath, oldCertificatePath)

    // Create a fresh secure context, renewing the certificate in the process.
    // Once the secure context has been created, it will automatically be used
    // for any new connection attempts in the future.
    await this.createSecureContext(/* renewCertificate = */ true)

    // Delete the backup of the old certificate.
    fs.rmSync(oldCertificateIdentityPath)
    fs.rmSync(oldCertificatePath)
  }


  /**
    Checks if the certificate needs to be renewed (if it is within 30 days of its expiry date) and, if so,
    renews it. While the method is async, the result is not awaited on usage. Instead, it is a fire-and-forget
    method that‚Äôs called via a daily interval.

    @access public
    @category async
    @param {boolean} [forceRenew=false] - Force renewal regardless of ARI response (for testing)
    @returns {Promise} Fulfils immediately if certificate doesn‚Äôt need renewal. Otherwise, fulfils once certificate
                       has been renewed.
  */
  async checkForRenewal (forceRenew = false) {
    log( '   üßê    ‚ù®auto-encrypt‚ù© Checking if we need to renew the certificate‚Ä¶ ')

    await this.#initialiseAcmeRequest()

    if (forceRenew) {
      log('   üö®    ‚ù®auto-encrypt‚ù© Forcing renewal (forceRenew === true)')
      await this.renewCertificate()
      log(`   üå±    ‚ù®auto-encrypt‚ù© Successfully renewed Let‚Äôs Encrypt certificate.`)
      return
    }

    const renewalInfoUrl = AcmeRequest.directory.renewalInfoUrl
    if (renewalInfoUrl && this.ariCertId) {
      try {
        const response = await fetch(`${renewalInfoUrl}/${this.ariCertId}`)

        if (response.ok) {
          const renewalInfo = await response.json()
          const startDate = Temporal.Instant.from(renewalInfo.suggestedWindow.start)
          const now = Temporal.Now.instant()
          if (Temporal.Instant.compare(now, startDate) >= 0) {
            // We‚Äôre past the start date of the renewal window. So we should renew.
            log(`   üå±    ‚ù®auto-encrypt‚ù© Certificate needs renewal (ARI). Renewing certificate‚Ä¶`)
            // Note: this is not a blocking process. We transparently start using the new certificate
            // when it is ready.
            await this.renewCertificate()
            log(`   üå±    ‚ù®auto-encrypt‚ù© Successfully renewed Let‚Äôs Encrypt certificate.`)
          } else {
            log('   üëç    ‚ù®auto-encrypt‚ù© Certificate does not need renewal (ARI). Will check again in an hour.')
          }
          return
        } else {
          // If ARI is not supported or the certificate is not found, we fall back to expiry date check.
          // (404 is the expected response if the server does not have renewal info for the certificate,
          // while Pebble sometimes returns 400 if the issuer is unknown).
          if (response.status === 404) {
            log('   ‚ÑπÔ∏è    ‚ù®auto-encrypt‚ù© No ARI renewal information found for this certificate (404). Falling back to expiry check.')
          } else if (response.status === 400) {
            const body = await response.json().catch(() => ({}))
            if (body.detail && body.detail.includes('no known issuer matches')) {
              log('   ‚ÑπÔ∏è    ‚ù®auto-encrypt‚ù© ARI check: Issuer unknown to server (common when using Pebble across multiple runs). Falling back to expiry check.')
            } else {
              log(`   ‚ö†    ‚ù®auto-encrypt‚ù© ARI check failed (400 Bad Request): ${body.detail || 'Unknown error'}. Falling back to expiry check.`)
            }
          } else {
            log(`   ‚ö†    ‚ù®auto-encrypt‚ù© Failed ARI check for certificate renewal (status ${response.status}). Falling back to expiry check.`)
          }
        }
      } catch (error) {
        log(`   ‚ö†    ‚ù®auto-encrypt‚ù© Error during ARI check for certificate renewal: ${error.message}`)
      }
    }

    // Fallback: If ARI is not supported or the check failed, use expiry date.
    log('   üßê    ‚ù®auto-encrypt‚ù© ARI not available or check failed. Falling back to expiry date check.')
    const twoDaysInMs = 2 * 24 * 60 * 60 * 1000
    const now = Temporal.Now.instant()
    const expiryDate = this.expiryDate
    const diff = expiryDate.since(now).total({ unit: 'milliseconds' })

    if (diff < twoDaysInMs) {
      log(`   üå±    ‚ù®auto-encrypt‚ù© Certificate needs renewal (expiry date). Renewing certificate‚Ä¶`)
      await this.renewCertificate()
      log(`   üå±    ‚ù®auto-encrypt‚ù© Successfully renewed Let‚Äôs Encrypt certificate.`)
    } else {
      log('   üëç    ‚ù®auto-encrypt‚ù© Certificate does not need renewal (expiry date). Will check again tomorrow.')
    }
  }


  /**
    Starts checking for certificate renewals every hour (as ARI renewal
    windows on short-lived certificates are short ‚Äì 2.88 hours starting at around
    half-way mark of the certificate‚Äôs 160 hour lifetime according to
    https://community.letsencrypt.org/t/ari-recommendation-may-cause-renewal-outside-suggested-window/235059/25).

    @param {boolean} [alsoCheckNow=false] If true, will also immediately check for renewal when the function is
                                          called (use this when loading a previously-provisioned and persisted
                                          certificate from disk).
    @category sync
    @access public
  */
  startCheckingForRenewal (alsoCheckNow = false) {
    // Also check for renewal immediately if asked to.
    if (alsoCheckNow) {
      this.checkForRenewal()
    }

    // And also once a day from thereon for as long as the server is running.
    const onceAnHour = 1 /* hours */ * 60 /* minutes */ * 60 /* seconds */ * 1000 /* ms */
    this.#checkForRenewalIntervalId = setInterval(this.checkForRenewal.bind(this), onceAnHour)

    log('   ‚è∞    ‚ù®auto-encrypt‚ù© Set up timer to check for certificate renewal (ARI) once an hour.')
  }

  /**
    Stops the timer that checks for renewal daily. Use this during housekeeping before destroying this object.

    @category sync
    @access public
  */
  stopCheckingForRenewal () {
    clearInterval(this.#checkForRenewalIntervalId)
  }

  /**
    @param { Uint8Array<ArrayBuffer> | string } input
  */
  base64UrlEncode ( input ) {
    const base64 = Buffer.from(typeof input === 'string' ? new TextEncoder().encode(input) : input).toString('base64')

    return base64
      .replace(/\+/g, '-') // Replace + with -
      .replace(/\//g, '_') // Replace / with _
      .replace(/=+$/, '')  // Remove trailing =
  }

  /**
    @param {any} certificatePem - (Typed as any as underlying library doesn‚Äôt contain type information.)
  */
  parseDetails (certificatePem) {
    const certificate = (X509Certificate.decode(certificatePem, 'pem', {label: 'CERTIFICATE'})).tbsCertificate

    const serialNumber = certificate.serialNumber

    // Calculate ARI CertID as per RFC 9773 ¬ß 4.1.
    const akiExtension = certificate.extensions.find((/** @type {{ extnID: string }} */ extension) => extension.extnID === 'authorityKeyIdentifier')
    let ariCertId = null
    if (akiExtension && akiExtension.extnValue.keyIdentifier) {
      const encodedAuthorityKeyIdentifier = this.base64UrlEncode(akiExtension.extnValue.keyIdentifier)

      const serialDer = CertificateSerialNumber.encode(serialNumber, 'der')
      // SerialNumber is an INTEGER. DER for INTEGER is 02 [LENGTH] [CONTENT]
      // We want only the content octets.
      let contentStart = 2
      if (serialDer[1] & 0x80) {
        // Long form length
        contentStart = 2 + (serialDer[1] & 0x7f)
      }
      const encodedSerialNumber = this.base64UrlEncode(serialDer.slice(contentStart))

      ariCertId = `${encodedAuthorityKeyIdentifier}.${encodedSerialNumber}`
    }

    const issuer = certificate.issuer.value[0][0].value.toString('utf-8').slice(2).trim()
    const issuedAt = new Date(certificate.validity.notBefore.value)
    const expiresAt = new Date(certificate.validity.notAfter.value)
    const subject = certificate.subject.value.length > 0 ? certificate.subject.value[0][0].value.toString('utf-8').slice(2).trim() : '(No subject)'

    const alternativeNames = ((certificate.extensions.filter((/** @type {{ extnID:string }} */ extension) => {
      return extension.extnID === 'subjectAlternativeName'
    }))[0].extnValue).map((/** @type {{ type: string, value: any }} */ name) => {
      if (name.type === 'iPAddress') {
        // IPv4 or IPv6.
        if (name.value.length === 4) {
          // IPv4
          return name.value.join('.')
        } else if (name.value.length === 16) {
          // IPv6
          const groups = []
          for (let i = 0; i < 16; i += 2) {
            groups.push(name.value.readUInt16BE(i).toString(16))
          }
          // Note: we don‚Äôt perform IPv6 compression (RFC 5952) here as this is for a debug display.
          return groups.join(':')
        }
      }
      return name.value
    })

    return {
      serialNumber,
      issuer,
      subject,
      alternativeNames,
      issuedAt,
      expiresAt,
      ariCertId
    }
  }

  get __checkForRenewalIntervalId () {
    return this.#checkForRenewalIntervalId
  }

  /**
    Custom inspection string.
  */
  [util.inspect.custom] () {
    return `# Certificate
    ${!this.isProvisioned ? 'Certificate not provisioned.' : `
                         Key              Value
                         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      Serial number     .serialNumber     ${this.serialNumber}
      Issuer            .issuer           ${this.issuer}
      Subject           .subject          ${this.subject}
      Alternative names .alternativeNames ${this.alternativeNames.join(', ')}
      Issue date        .issueDate        ${this.issueDate}
      Expiry date       .expiryDate       ${this.expiryDate}
    `}
    `
  }
}
