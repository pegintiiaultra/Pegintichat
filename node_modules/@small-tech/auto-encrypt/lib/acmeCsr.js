/**
  ACME CSR

  Given a regular Certification Request in PEM format, returns an
  ACME-formatted CSR (single-line PEM without the header or footer and encoded
  in base64Url instead of base64 format).

  See RFC 8555 § 7.4 (Applying for Certificate Issuance).

  Copyright © 2020-present Aral Balkan, Small Technology Foundation.
  License: AGPLv3 or later.
*/

import net from 'node:net'
import crypto from 'node:crypto'
import {
  CertificationRequest,
  CertificationRequestInfo,
  SubjectPublicKeyInfo,
  Extensions
} from './x.509/rfc5280.js'

/**
  Return an ACME-formatted (RFC 8555) CSR given a list of domains and a crypto.KeyObject.

  @param { string[] }   domains
  @param { crypto.KeyObject } key
  @returns { string } An ACME-formatted CSR in PEM format.
*/
export default function (domains, key) { return pemToAcmeCsr(csrAsPem(domains, key)) }

/**
  Create a CSR given a list of domains and a crypto.KeyObject.

  @param { string[] }   domains
  @param { crypto.KeyObject } key
  @returns { string } A CSR in PEM format.
*/
function csrAsPem (domains, key) {
  const altNames = domains.map(domain => {
    if (net.isIP(domain)) {
      // IP address.
      let ipBytes
      if (net.isIPv4(domain)) {
        ipBytes = Buffer.from(domain.split('.').map(Number))
      } else {
        // IPv6.
        const parts = domain.split('::')
        const left = parts[0] ? parts[0].split(':') : []
        const right = parts[1] ? parts[1].split(':') : []
        const missing = 8 - (left.length + right.length)
        const expanded = [...left, ...Array(missing).fill('0'), ...right]
        ipBytes = Buffer.from(expanded.flatMap(x => {
            const hex = x.padStart(4, '0')
            return [parseInt(hex.slice(0, 2), 16), parseInt(hex.slice(2, 4), 16)]
        }))
      }

      return { type: 'iPAddress', value: ipBytes }
    } else {
      // Domain.
      return { type: 'dNSName', value: domain }
    }
  })

  const spki = crypto.createPublicKey(key).export({ type: 'spki', format: 'der' })
  const subjectPKInfo = SubjectPublicKeyInfo.decode(spki, 'der')

  const certificationRequestInfo = {
    version: 0,
    // According to RFC 8555, we *either* need to specify the subject or
    // the subjectAltName so skip the subject. (We use an empty subject.)
    subject: { type: 'rdnSequence', value: [] },
    subjectPKInfo,
    attributes: [
      {
        type: [1, 2, 840, 113549, 1, 9, 14], // extensionRequest
        values: [
          Extensions.encode([
            {
              extnID: 'subjectAlternativeName',
              critical: false,
              extnValue: altNames
            }
          ], 'der')
        ]
      }
    ]
  }

  const tbsDer = CertificationRequestInfo.encode(certificationRequestInfo, 'der')
  const signature = crypto.sign('sha256', tbsDer, key)

  const csr = {
    certificationRequestInfo,
    signatureAlgorithm: {
      algorithm: [1, 2, 840, 113549, 1, 1, 11], // sha256WithRSAEncryption
      parameters: Buffer.alloc(0)
    },
    signature: {
      data: signature,
      unused: 0
    }
  }

  const der = CertificationRequest.encode(csr, 'der')
  const pem = `-----BEGIN CERTIFICATE REQUEST-----\n${der.toString('base64').match(/.{1,64}/g).join('\n')}\n-----END CERTIFICATE REQUEST-----`
  return pem
}

/**
  @param { string } csr
*/
function pemToAcmeCsr (csr) {
  csr = pemToHeaderlessSingleLinePem(csr)
  csr = base64ToBase64Url(csr)
  return csr
}

/**
  Strip the PEM headers and covert to a non-newline delimited Base64Url-encoded
  string as required by RFC 8555 (would be nice if this was explicitly-mentioned in the spec).

  @param { string } str
*/
function pemToHeaderlessSingleLinePem (str) {
  return str
    .replace('-----BEGIN CERTIFICATE REQUEST-----', '')
    .replace('-----END CERTIFICATE REQUEST-----', '')
    .replace(/\n/g, '')
}

/**
  Convert base64-encoded string into a base64Url-encoded string.

  @param { string } str
*/
function base64ToBase64Url (str) {
  return str
   .replace(/\+/g, '-')
   .replace(/\//g, '_')
   .replace(/=/g, '')
   .replace(/\r/g, '')
}
