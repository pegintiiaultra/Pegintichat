/**
  Identity (abstract base class; do not use directly).


  Copyright ¬© 2020 Aral Balkan, Small Technology Foundation.
  License: AGPLv3 or later.
*/

import util from 'util'
import fs from 'fs'
import crypto from 'node:crypto'
import Throws from './util/Throws.js'
import log from './util/log.js'

const throws = new Throws({
  [Symbol.for('UnsupportedIdentityType')]: (/** @type {string} */ identityFilePath) => `The identity file path passed (${identityFilePath}) is for an unsupported identity type.`
})

export default class Identity {
  /** @type { crypto.KeyObject } */
  _key

  /**
    Generates, stores, loads, and saves an identity from/to the file
    storage settings path. Meant to be subclassed and instantiated by different
    singletons for different types of Identity (e.g., AccountIdentity and
    DomainIdentity).

    The private key uses the RS256 algorithm with a 2048-bit key.

    @param { import('./Configuration.js').default | void } configuration
    @param { string | void } identityFilePathKey
  */
  constructor (configuration = throws.ifMissing(), identityFilePathKey = throws.ifMissing()) {
    /** @type {string} */
    const identityFilePath = /** @type { import('./Configuration.js').default } */ (configuration)[/** @type {string} */ (identityFilePathKey)]

    if (identityFilePath === undefined) {
      throws.error(Symbol.for('UnsupportedIdentityType'))
    }

    log(`   üë§    ‚ù®auto-encrypt‚ù© Creating identity (${identityFilePath})`)

    this.#identityFilePath = identityFilePath

    if (!fs.existsSync(this.#identityFilePath)) {
      // The identity file does not already exist, generate and save it.
      const { privateKey } = crypto.generateKeyPairSync('rsa', {
        modulusLength: 2048
      })
      this._key = privateKey
      fs.writeFileSync(this.#identityFilePath, this.privatePEM, 'utf-8')
    } else {
      // Load the key from storage.
      const _privatePEM = fs.readFileSync(this.#identityFilePath, 'utf-8')
      this._key = crypto.createPrivateKey(_privatePEM)
    }

    // Pre-calculate thumbprint synchronously using node:crypto as jose.calculateJwkThumbprint is async.
    // RFC 7638: for RSA, the thumbprint is calculated over 'e', 'kty', and 'n' in lexicographical order.
    const jwk = this.publicJWK
    const thumbprintSource = JSON.stringify({
      e: jwk.e,
      kty: jwk.kty,
      n: jwk.n
    })
    this.#thumbprint = crypto.createHash('sha256').update(thumbprintSource).digest('base64url')
  }

  //
  // Accessors.
  //

  // The KeyObject instance.
  get key () { return this._key }

  // Returns the private key in PEM format.
  get privatePEM () { return this._key.export({ type: 'pkcs8', format: 'pem' }).toString() }

  // The JWK thumbprint as calculated according to
  // RFC 7638 (https://tools.ietf.org/html/rfc7638).
  get thumbprint () { return this.#thumbprint }

  // Returns JWK-formatted objects.
  get privateJWK () { return this._key.export({ format: 'jwk' }) }
  get publicJWK  () {
    const jwk = this.privateJWK
    delete jwk.d
    delete jwk.p
    delete jwk.q
    delete jwk.dp
    delete jwk.dq
    delete jwk.qi
    return jwk
  }

  // The file path of the private key (saved in PEM format).
  get filePath   () { return this.#identityFilePath }

  //
  // Control access to read-only properties.
  //
  set key        (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'key')        }
  set privatePEM (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'privatePEM') }
  set thumbprint (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'thumbprint') }
  set privateJWK (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'privateJWK') }
  set publicJWK  (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'publicJWK')  }
  set filePath   (_value) { throws.error(Symbol.for('ReadOnlyAccessorError'), 'filePath')   }

  // Custom object description for console output (for debugging).
  [util.inspect.custom] () {
    return `
      # Identity

      Generates, stores, loads, and saves an identity (JWT OKP key using
      Ed25519 curve) from/to file storage.

      - Identity file path: ${this.filePath}

      ## Properties

      - .key        : the crypto.KeyObject instance
      - .privatePEM : PEM representation of the private key
      - .thumbprint : JWK thumbprint calculated according to RFC 7638
      - .privateJWK : JavaScript object representation of JWK (private key)
      - .publicJWK  : JavaScript object representation of JWK (public key)
      - .filePath   : The file path of the private key (saved in PEM format)

      To see key details, please log() the .key property.
    `
  }

  //
  // Private
  //
  /** @type {string} */
  #identityFilePath = null
  #thumbprint = null
}
