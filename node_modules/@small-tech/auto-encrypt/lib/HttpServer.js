/**

  HttpServer

  (Singleton; please use HttpServer.getSharedInstance() to access.)

  A simple HTTP server that:

   A. While provisioning Let‚Äôs Encrypt certificates:
   =================================================

   Acts as a challenge server. See RFC 8555 ¬ß 8.3 (HTTP Challenge)

   Responds to http-01 challenges and forwards all other
   requests to an HTTPS server that it expects to be active at the same domain.

   B. At all other times:
   ======================

   Forwards http requests to https requests using a 307 redirect.

  Copyright ¬© 2020 Aral Balkan, Small Technology Foundation.
  License: AGPLv3 or later.
*/

import http from 'http'
import encodeUrl from 'encodeurl'
import log from './util/log.js'

export default class HttpServer {
  //
  // Singleton access (async).
  //
  /** @type { HttpServer } */
  static instance = null
  static isBeingInstantiatedViaSingletonFactoryMethod = false

  // Is the HTTP server acting as a Let‚Äôs Encrypt challenge server?
  #isChallengeServer = false

  /** @typedef { (request: http.IncomingMessage, response: http.ServerResponse) => Boolean } Responder

  /** @type Array<Responder> */
  responders

  static async getSharedInstance () {
    if (HttpServer.instance === null) {
      HttpServer.isBeingInstantiatedViaSingletonFactoryMethod = true
      HttpServer.instance = new HttpServer()
      await HttpServer.instance.init()
    }
    return HttpServer.instance
  }

  static async destroySharedInstance () {
    if (HttpServer.instance === null) {
      log('   üöÆ    ‚ù®auto-encrypt‚ù© HTTP Server was never setup. Nothing to destroy.')
      return
    }
    log('   üöÆ    ‚ù®auto-encrypt‚ù© Destroying HTTP Server‚Ä¶')
    await HttpServer.instance.destroy()
    HttpServer.instance = null
    log('   üöÆ    ‚ù®auto-encrypt‚ù© HTTP Server is destroyed.')
  }

  /**
    Adds a responder to this server‚Äôs responders list.

    @param { Responder } responder
  */
  addResponder (responder) {
    this.responders.push(responder)
  }

  //
  // Private.
  //

  constructor () {
    // Ensure singleton access.
    if (HttpServer.isBeingInstantiatedViaSingletonFactoryMethod === false) {
      throw new Error('HttpServer is a singleton. Please instantiate using the HttpServer.getSharedInstance() method.')
    }
    HttpServer.isBeingInstantiatedViaSingletonFactoryMethod = false

    this.responders = []

    // Create the HTTP server to loop through responses until one handles the request or,
    // if none of them do, forward any other insecure requests we receive to an HTTPS
    // server that we expect to be running at the same domain.
    this.server = http.createServer((request, response) => {

      if (this.#isChallengeServer) {
        // Act as a Let‚Äôs Encrypt challenge server.
        let responded = false

        log(`   üì•    ‚ù®auto-encrypt‚ù© Received HTTP request: ${request.url} on ${request.headers.host}`)

        for (let i = 0; i < this.responders.length; i++) {
          const responder = this.responders[i]
          responded = responder(request, response)
          if (responded) break
        }

        // If this is not an ACME authorisation request, as nothing else should be using insecure HTTP,
        // forward the request to HTTPS.
        if (!responded) {
          log(`   ‚ö†    ‚ù®auto-encrypt‚ù© Received non-ACME HTTP request for ${request.url}, not responding.`)
          response.statusCode = 403
          response.end('403: forbidden')
        }
      } else {
        // Act as an HTTP to HTTPS forwarder.
        // (This means that servers using Auto Encrypt will get automatic HTTP to HTTPS forwarding
        // and will not fail if they are accessed over HTTP.)
        let httpsUrl = null
        try {
          httpsUrl = new URL(`https://${request.headers.host}${request.url}`)
        } catch (error) {
          log(`   ‚ö†    ‚ù®auto-encrypt‚ù© Failed to redirect HTTP request: ${error}`)
          response.statusCode = 403
          response.end('403: forbidden')
          return
        }

        // Redirect HTTP to HTTPS.
        log(`   üëâ    ‚ù®auto-encrypt‚ù© Redirecting HTTP request to HTTPS: ${httpsUrl.toString()}`)
        response.statusCode = 307
        response.setHeader('Location', encodeUrl(httpsUrl.toString()))
        response.end()
      }
    })
  }

  /**
    Sets the state of the server (either to challenge server (true) or to HTTP -> HTTPS forwarding server (false)).

    @param { Boolean } state
  */
  set challengeServer (state) {
    if (state) {
      log(`   üîí    ‚ù®auto-encrypt‚ù© HTTP server is now only responding to Let‚Äôs Encrypt challenges.`)
    } else {
      log(`   üîí    ‚ù®auto-encrypt‚ù© HTTP server is now forwarding HTTP requests to HTTPS (307).`)
    }
    this.#isChallengeServer = state
  }

  async init () {
    // Note: the server is created on Port 80. On Linux, you must ensure that the Node.js process has
    // ===== the correct privileges for this to work. Looking forward to removing this notice once Linux
    // leaves the world of 1960s mainframe computers and catches up to other prominent operating systems
    // that don‚Äôt have this archaic restriction which is security theatre at best and a security
    // vulnerability at worst in the global digital network age.
    await new Promise((resolve, reject) => {
      try {
        // Listen on all IP addresses, including IPv6.
        this.server.listen(80, '::', () => {
          log(`   üîí    ‚ù®auto-encrypt‚ù© HTTP server is listening on port 80.`)
          resolve()
        })
      } catch (error) {
        reject(error)
      }
    })
  }

  async destroy () {
    if (!this.server.listening) {
      log('   üöÆ    ‚ù®auto-encrypt‚ù© HTTP Server is not listening. Nothing to destroy.')
      return
    }

    // Starts killing all connections and closes the server.
    this.server.closeAllConnections()

    await new Promise((resolve, reject) => {
      this.server.close(error => {
        if (error) {
          // If the server was already closed or not running, we don't want to throw an error.
          if (error.code === 'ERR_SERVER_NOT_RUNNING') {
            resolve()
            return
          }
          console.error(error)
          reject(error)
        }
        resolve()
      })
    })
  }
}
