/**
  Automatically provisions and renews Let‚Äôs Encrypt‚Ñ¢ TLS certificates for Node.js¬Æ https servers (as used in @small-tech/https and Kitten.)

  Implements the subset of RFC 8555 ‚Äì Automatic Certificate Management Environment (ACME) ‚Äì necessary for a Node.js https server to provision TLS certificates from Let‚Äôs Encrypt using the HTTP-01 challenge.

  The certificates are provisioned, if necessary, at time of server creation, prior to server start with hourly renewal checks  and automatic renewals.

  Auto Encrypt uses the new Let‚Äôs Encrypt `shortlived` profile *exclusively*,  which means certificates are valid for (and renewed before) 160 hours. This should occur at around the 80 hour mark of the certificate‚Äôs lifespan, in accordance with data returned by ACME Renewal Information (ARI).

  Auto Encrypt also implements automatic support for obtaining certificates on IPv4 and IPv6 addresses to enable the use of Web Numbers on the Small Web (see https://ar.al/2025/06/25/web-numbers/).

  Remember that Auto Encrypt is for the Small Web (peer-to-peer Web). You might find it useful for everyday web purposes also but it is specifically focused for Small Web use cases and explicitly does not aim to be a generic or exhaustive ACME client.

  @module @small-tech/auto-encrypt
  @copyright ¬© 2020-present Aral Balkan, Small Technology Foundation.
  @license AGPLv3 or later.
 */

import os from 'node:os'
import util from 'node:util'
import net from 'node:net'
import https from 'node:https'
import monkeyPatchTls from './lib/staging/monkeyPatchTls.js'
import LetsEncryptServer from './lib/LetsEncryptServer.js'
import Configuration from './lib/Configuration.js'
import Certificate from './lib/Certificate.js'
import AcmeRequest from './lib/AcmeRequest.js'
import Pluralise from './lib/util/Pluralise.js'
import Throws from './lib/util/Throws.js'
import HttpServer from './lib/HttpServer.js'
import IPAddresses from './lib/IPAddresses.js'
export { IPAddresses }
import log from './lib/util/log.js'

// Custom errors thrown by the autoEncrypt function.
const throws = new Throws({
  [Symbol.for('BusyProvisioningCertificateError')]:
    () => 'We‚Äôre busy provisioning TLS certificates and rejecting all other calls at the moment.',

  [Symbol.for('IPv4AddressNotFound')]:
    () => 'IPv4 certificate requested but could not automatically find machine‚Äôs IPv4 address',

  [Symbol.for('IPv6AddressNotFound')]:
    () => 'IPv6 certificates requested but could not automatically find any stable IPv6 addresses',

  [Symbol.for('SNIIgnoreUnsupportedDomainError')]:
    (/** @type {string} */ serverName, /** @type {Array<string>} */ domains) => {
      return `SNI: Not responding to request for unsupported domain ${serverName} (valid ${Pluralise.word('domain', domains)} ${Pluralise.isAre(domains)} ${domains}).`
    }
})

/**
  @typedef {import('./index.d.ts').AutoEncryptedServer} AutoEncryptedServer
*/

/**
  Auto Encrypt is a static class. Please do not instantiate.

  Use: AutoEncrypt.https.createServer(‚Ä¶)

  @alias module:@small-tech/auto-encrypt
  @hideconstructor
*/
export default class AutoEncrypt {
  /** @type { AutoEncryptedServer } */
  static server = null

  /** @type { import('./lib/LetsEncryptServer.js').default | null } */
  static letsEncryptServer = null

  /** @type { string[] | null } */
  static defaultDomains    = null

  /** @type { string[] | null } */
  static domains           = null

  /** @type { string | null } */
  static settingsPath      = null

  /** @type { ((req: import('http').IncomingMessage, res: import('http').ServerResponse) => void) | null } */
  static listener          = null

  /** @type { Certificate | null } */
  static certificate       = null

  /**
    Enumeration.

    @type {LetsEncryptServer.type}
    @readonly
    @static
  */
  static serverType = LetsEncryptServer.type

  /**
    By aliasing the https property to the AutoEncrypt static class itself, we enable
    people to add AutoEncrypt to their existing apps by requiring the module
    and prefixing their https.createServer(‚Ä¶) line with await AutoEncrypt:

    @example import AutoEncrypt from '@small-tech/auto-encrypt'
    const server = await AutoEncrypt.https.createServer()

    @static
  */
  static get https () { return AutoEncrypt }

  /**
    Automatically manages Let‚Äôs Encrypt certificate provisioning and renewal for Node.js
    https servers using the HTTP-01 challenge on first hit of an HTTPS route via use of
    the Server Name Indication (SNI) callback.

    @static

    @param {import('tls').SecureContextOptions & {
      domains?: Array<string>,
      serverType?: number,
      settingsPath?: string,
      ipv4?: boolean,
      ipv6?: boolean,
      ipOnly?: boolean,
      SNICallback?: (serverName: string, callback: (...args: any[]) => void) => Promise<void> | void
    } | ((...any: any[]) => void)} _options
    
    @param {(...any: any[]) => void} [_listener]

    @returns {Promise<import('./index.d.ts').AutoEncryptedServer>} A promise for the server instance (a monkey-patched https.Server similar to the one returned by Node‚Äôs https.createServer() method).
  */
  static async createServer(_options, _listener) {
    //  Auto Encrypt only supports one server per Node process. As such, if the server already exists, return the existing instance.
    if (this.server !== null) {
      log('   ‚òùÔ∏è    ‚ù®auto-encrypt‚ù© Returning reference to existing server (there can be only one‚Ä¶ per process).')
      return this.server
    }

    // The first parameter is optional. If omitted, the first argument, if any, is treated as the request listener.
    if (typeof _options === 'function') {
      _listener = _options
      _options = {}
    }

    const defaultPebbleDomains               = []
    const options                            = _options || {}
    const letsEncryptServer                  = new LetsEncryptServer(options.serverType || LetsEncryptServer.type.PRODUCTION)
    const listener                           = _listener || null
    const settingsPath                       = options.settingsPath || null

    let defaultStagingAndProductionDomains = []
    if (!options.ipOnly) {
      defaultStagingAndProductionDomains.push(os.hostname())
      defaultPebbleDomains.push('localhost')
      defaultPebbleDomains.push('pebble')
    }

    // Check if the passed list of domains contains an IP address. If it does, we can skip our automatic IP address detection and use the provides ones.
    let domainsListContainsAtLeastOneIPAddress = false
    if (options.domains) {
      const ip = options.domains.find(domain => net.isIP(domain) !== 0)
      if (ip !== undefined) {
        domainsListContainsAtLeastOneIPAddress = true
      }
    }

    if (!domainsListContainsAtLeastOneIPAddress) {
      // Domains list does not contain any IP addresses, if auto detection is requested, auto detect the requested IP types.

      /** @type { IPAddresses } */
      let ipAddresses
      if (options.ipv4 === true || options.ipv6 === true) {
        ipAddresses = await IPAddresses.getInstanceAsync()
      }

      if (options.ipv4 === true) {
        if (letsEncryptServer.type === LetsEncryptServer.type.PEBBLE) {
          const localIPv4Address = '127.0.0.1'
          defaultPebbleDomains.push(localIPv4Address)
          log(`   üìç    ‚ù®auto-encrypt‚ù© Will provision TLS certificate from Pebble server for local IPv4 address (${localIPv4Address})`)
        } else {
          if (ipAddresses.hasIPv4Address) {
            const ipv4Address = ipAddresses.ipv4Address
            defaultStagingAndProductionDomains.push(ipv4Address)
            log(`   üìç    ‚ù®auto-encrypt‚ù© Will provision TLS certificate for detected IPv4 address: ${ipv4Address}`)
          } else {
            throws.error(Symbol.for('IPv4AddressNotFound'))
          }
        }
      }

      if (options.ipv6 === true) {
        if (letsEncryptServer.type === LetsEncryptServer.type.PEBBLE) {
          // IPv6: Pebble.
          const localIPv6Address = '::1'
          defaultPebbleDomains.push(localIPv6Address)
          log(`   üìç    ‚ù®auto-encrypt‚ù© Will provision TLS certificate from Pebble server for local IPv6 address (${localIPv6Address})`)
        } else {
          // IPv6: Staging and production.
          const ipv6Addresses = ipAddresses.ipv6Addresses
          if (ipv6Addresses.length > 0) {
            defaultStagingAndProductionDomains = defaultStagingAndProductionDomains.concat(ipv6Addresses)
            ipv6Addresses.forEach(ipv6Address => defaultPebbleDomains.push(ipv6Address))
            log(`   üìç    ‚ù®auto-encrypt‚ù© Will provision TLS certificate for detected stable IPv6 address${ipv6Addresses.length > 1 ? 'es' : ''}: ${ipv6Addresses}`)
          } else {
            throws.error(Symbol.for('IPv6AddressNotFound'))
          }
        }
      }
    }

    let defaultDomains = defaultStagingAndProductionDomains

    // Behaviour specific to Let‚Äôs Encrypt server type (Pebble/staging).
    switch (letsEncryptServer.type) {
      case LetsEncryptServer.type.PEBBLE:
        options.domains = null
        defaultDomains = defaultPebbleDomains
      break

      case LetsEncryptServer.type.STAGING:
        // Add the intermediary certificate to Node.js‚Äôs trust store (only valid during the current Node.js process) so that Node will accept the certificate. Useful when running tests against the staging server.
        monkeyPatchTls()
      break
    }

    const domains = options.domains || defaultDomains

    // Delete the Auto Encrypt-specific properties from the options object to not pollute the namespace.
    delete options.domains
    delete options.serverType
    delete options.settingsPath
    delete options.ipv4
    delete options.ipv6
    delete options.ipOnly

    const configuration = new Configuration({ settingsPath, domains, server: letsEncryptServer})
    const certificate = new Certificate(configuration)

    this.letsEncryptServer = letsEncryptServer
    this.defaultDomains    = defaultDomains
    this.domains           = domains
    this.settingsPath      = settingsPath
    this.listener          = listener
    this.certificate       = certificate

    // Start HTTP server.
    log('   üåç    ‚ù®auto-encrypt‚ù© Starting HTTP challenge responder server‚Ä¶')
    await HttpServer.getSharedInstance()

    // Provision certificate (if required).
    log(`   üìÉ    ‚ù®auto-encrypt‚ù© Provisioning certificate (if required) for domains: ${domains.join(', ')}‚Ä¶`)
    await certificate.getSecureContext()
    log('   ‚úÖ    ‚ù®auto-encrypt‚ù© Certificate provisioned (or already exists).')

    // Pass the certificate and key to the https.createServer options as well.
    // This is required for IP hits (which don't use SNI) and also acts as the 
    // default certificate.
    options.key = certificate.key
    options.cert = certificate.pem

    // Create node:https server.
    const server = /** @type {import('./index.d.ts').AutoEncryptedServer} */ (/** @type {unknown} */ (https.createServer(options, listener)))
    this.server = server

    //
    // Monkey-patch server.
    //

    /**
      Auto Encrypt‚Äôs async version of Node‚Äôs built-in `https.listen()` method.

      You can use this method with exactly the same signature as Node‚Äôs and
      with a callback but, ideally, you should be awaiting it and not using the callback.
    
      @param {...*} args - Arguments to pass to https.Server.listen()
      @returns {Promise<AutoEncryptedServer>}
    */
    const listenAsync = async function (...args) {
      return new Promise((resolve, reject) => {
        const server = this['__original_listen__'](...args)
          .once('listening', () => resolve(server))
          .once('error', reject)
      })
    }
    server['__original_listen__'] = server.listen.bind(server)
    server.listen = listenAsync.bind(server)

    /**
      Auto Encrypt Localhost‚Äôs async version of Node‚Äôs built-in `https.close()` method.

      Unlike Node‚Äôs `close()` method, this version also calls `closeAllConnections()` so it
      will sever any existing idle and active connections. When `await`ed, this call will
      only return once `node:https`‚Äôs close callback is called. This is also where your
      callback will fire, if you are using Node‚Äôs original method signature will callbacks.

      You can still use this method with exactly the same signature as Node‚Äôs and
      with a callback but, ideally, you should be awaiting it and not using the callback.
    
      @returns {Promise<void>}
    */
    const closeAsync = async function () {
      // Clean-up our own house.
      await AutoEncrypt.shutdown()

      // Start shutting down the HTTPS server.
      const closePromise = new Promise((resolve, reject) => {
        this['__original_close__']((/** @type { Error } */ error) => {
          if (error) {
            reject(error)
          } else {
            resolve()
          }
        })
      })

      // Sever all idle and active connections.
      this.closeAllConnections()

      // Only now await the promise.
      // (See note at: https://nodejs.org/docs/latest-v24.x/api/http.html#servercloseallconnections)
      await closePromise
    }
    server['__original_close__'] = server.close.bind(server)
    server.close = closeAsync.bind(server)

    // Return the server singleton.
    return this.server
  }
  
  /**
    Shut Auto Encrypt down. Do this before app exit. Performs necessary clean-up and removes
    any references that might cause the app to not exit.
  */
  static async shutdown () {
    if (this.certificate) {
      this.certificate.stopCheckingForRenewal()
    }
    await HttpServer.destroySharedInstance()
    AcmeRequest.uninitialise()
    this.server = null
  }

  //
  // Private.
  //

  // Custom object description for console output (for debugging).
  static [util.inspect.custom] () {
    return `
       # AutoEncrypt (static class)

        - Using Let‚Äôs Encrypt ${this.letsEncryptServer.name} server.
        - Managing TLS for ${this.domains.toString().replace(',', ', ')}${this.domains === this.defaultDomains ? ' (default domains)' : ''}.
        - Settings stored at ${this.settingsPath === null ? 'default settings path' : this.settingsPath}.
        - Listener ${typeof this.listener === 'function' ? 'is set' : 'not set'}.
    `
  }

  constructor () {
    throws.error(Symbol.for('StaticClassCannotBeInstantiatedError'))
  }
}
